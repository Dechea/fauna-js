{
  "version": 3,
  "sources": ["../../src/client-configuration.ts", "../../src/client.ts", "../../src/errors.ts", "../../src/regex.ts", "../../src/values.ts", "../../src/tagged-type.ts", "../../src/query-builder.ts"],
  "sourcesContent": ["import { ValueFormat } from \"./wire-protocol\";\n\n/**\n * Configuration for a client.\n */\nexport interface ClientConfiguration {\n  /**\n   * The {@link URL} of Fauna to call. See {@link endpoints} for some default options.\n   */\n  endpoint: URL;\n  /**\n   * Determines the encoded format expected for the query `arguments` field, and\n   * the `data` field of a successful response.\n   * @remarks **Note, it is very unlikely you need to change this value from its default.**\n   * By default the driver transmits type information over the wire. Fauna also assumes type information is\n   * transmitted by default and thus leaving this value undefined will allow Fauna and the driver to send and\n   * receive type data.\n   *  Type information allows the driver and Fauna to distinguish between types such as int\" and \"long\" which do not\n   * have a standard way of distinguishing in JSON.\n   * Since Fauna assumes typed information is transmitted by default, clients can leave this value undefined to make\n   * full usage of Fauna's primitive types.\n   * You can also explicitly set this to \"tagged\" to get the typing data sent.\n   * Rare use cases can also deal with standard JSON by setting the value to \"simple\". Not that the types\n   * enocodable in standard JSON are a subset of the types encodable in the default \"tagged\" format.\n   * It is not recommended that users use the \"simple\" format as you will lose the typing of your data. e.g. a \"Date\"\n   * will no longer be recognized by the Fauna as a \"Date\", but will instead be treated as a string.\n   */\n  format?: ValueFormat;\n  /**\n   * The maximum number of connections to a make to Fauna.\n   */\n  max_conns: number;\n  /**\n   * A secret for your Fauna DB, used to authorize your queries.\n   * @see https://docs.fauna.com/fauna/current/security/keys\n   */\n  secret: string;\n  /**\n   * The timeout of each query, in milliseconds. This controls the maximum amount of\n   * time Fauna will execute your query before marking it failed.\n   * Default is undefined which let's Fauna determine the query timeout to apply. This\n   * is recommended for most queries.\n   */\n  query_timeout_ms?: number;\n  /**\n   * If true, unconditionally run the query as strictly serialized.\n   * This affects read-only transactions. Transactions which write\n   * will always be strictly serialized.\n   */\n  linearized?: boolean;\n  /**\n   * The max number of times to retry the query if contention is encountered.\n   */\n  max_contention_retries?: number;\n\n  /**\n   * Tags provided back via logging and telemetry.\n   */\n  query_tags?: { [key: string]: string };\n  /**\n   * A traceparent provided back via logging and telemetry.\n   * Must match format: https://www.w3.org/TR/trace-context/#traceparent-header\n   */\n  traceparent?: string;\n}\n\n/**\n * An extensible interface for a set of Fauna endpoints.\n * @remarks Leverage the `[key: string]: URL;` field to extend to other endpoints.\n */\nexport interface Endpoints {\n  /** Fauna's cloud endpoint. */\n  cloud: URL;\n  /** Fauna's preview endpoint for testing new features - requires beta access. */\n  preview: URL;\n  /**\n   * An endpoint for interacting with local instance of Fauna (e.g. one running in a local docker container).\n   */\n  local: URL;\n  /**\n   * An alias for local.\n   */\n  localhost: URL;\n  /**\n   * Any other endpoint you want your client to support. For example, if you run all requests through a proxy\n   * configure it here. Most clients will not need to leverage this ability.\n   */\n  [key: string]: URL;\n}\n\n/**\n * A extensible set of endpoints for calling Fauna.\n * @remarks Most clients will will not need to extend this set.\n * @example\n * ## To Extend\n * ```typescript\n *   // add to the endpoints constant\n *   endpoints.myProxyEndpoint = new URL(\"https://my.proxy.url\");\n * ```\n */\nexport const endpoints: Endpoints = {\n  cloud: new URL(\"https://db.fauna.com\"),\n  preview: new URL(\"https://db.fauna-preview.com\"),\n  local: new URL(\"http://localhost:8443\"),\n  localhost: new URL(\"http://localhost:8443\"),\n};\n", "import { ClientConfiguration, endpoints } from \"./client-configuration\";\nimport type { QueryBuilder } from \"./query-builder\";\nimport type {\n  QueryRequest,\n  QueryRequestHeaders,\n  QueryResponse,\n} from \"./wire-protocol\";\n\nconst defaultClientConfiguration = {\n  max_conns: 10,\n  endpoint: endpoints.cloud,\n  timeout_ms: 60_000,\n};\n\n/**\n * Client for calling Fauna.\n */\nexport class Client {\n  /** The {@link ClientConfiguration} */\n  readonly clientConfiguration: ClientConfiguration;\n  /** last_txn this client has seen */\n  #lastTxn?: Date;\n  readonly headers = {};\n\n  constructor(clientConfiguration?: Partial<ClientConfiguration>) {\n    this.clientConfiguration = {\n      ...defaultClientConfiguration,\n      ...clientConfiguration,\n      secret: this.#getSecret(clientConfiguration),\n    };\n\n    this.headers = {\n      Authorization: `Bearer ${this.clientConfiguration.secret}`,\n      \"Content-Type\": \"application/json\",\n      \"X-Format\": \"simple\",\n    };\n\n    this.#setHeaders(this.clientConfiguration, this.headers);\n  }\n\n  #getSecret(partialClientConfig?: Partial<ClientConfiguration>): string {\n    let fallback = undefined;\n    if (typeof process === \"object\") {\n      fallback = process.env[\"FAUNA_SECRET\"];\n    }\n    const maybeSecret = partialClientConfig?.secret || fallback;\n    if (maybeSecret === undefined) {\n      throw new Error(\n        `You must provide a secret to the driver. Set it in an environmental variable named FAUNA_SECRET or pass it to the Client constructor.`\n      );\n    }\n    return maybeSecret;\n  }\n\n  /**\n   * Queries Fauna.\n   * @param request - a {@link QueryRequest} or {@link QueryBuilder} to build a request with.\n   *  Note, you can embed header fields in this object; if you do that there's no need to\n   *  pass the headers parameter.\n   * @param headers - optional {@link QueryRequestHeaders} to apply on top of the request input.\n   *   Values in this headers parameter take precedence over the same values in the request\n   *   parameter. This field is primarily intended to be used when you pass a QueryBuilder as\n   *   the parameter.\n   * @returns Promise&lt;{@link QueryResponse}&gt;.\n   * @throws {@link ServiceError} Fauna emitted an error. The ServiceError will be\n   *   one of ServiceError's child classes if the error can be further categorized,\n   *   or a concrete ServiceError if it cannot. ServiceError child types are\n   *   {@link AuthenticaionError}, {@link AuthorizationError}, {@link QueryCheckError}\n   *   {@link QueryRuntimeError}, {@link QueryTimeoutError}, {@link ServiceInternalError}\n   *   {@link ServiceTimeoutError}, {@link ThrottlingError}.\n   *   You can use either the type, or the underlying httpStatus + code to determine\n   *   the root cause.\n   * @throws {@link ProtocolError} the client a HTTP error not sent by Fauna.\n   * @throws {@link NetworkError} the client encountered a network issue\n   * connecting to Fauna.\n   * @throws A {@link ClientError} the client fails to submit the request\n   * due to an internal error.\n   */\n  async query<T = any>(\n    request: QueryRequest | QueryBuilder,\n    headers?: QueryRequestHeaders\n  ): Promise<QueryResponse<T>> {\n    if (\"query\" in request) {\n      return this.#query({ ...request, ...headers });\n    }\n    return this.#query(request.toQuery(headers));\n  }\n\n  async #query<T = any>(queryRequest: QueryRequest): Promise<QueryResponse<T>> {\n    const { query, arguments: args } = queryRequest;\n    this.#setHeaders(queryRequest, this.headers);\n\n    try {\n      const result: QueryResponse<T> = await fetch(\n        `${this.clientConfiguration.endpoint.toString()}/query/1`,\n        {\n          method: \"POST\",\n          headers: this.headers,\n          body: JSON.stringify({ query, arguments: args }),\n          keepalive: true,\n        }\n      ).then(async (res) => res.json());\n\n      if (\"errors\" in result) {\n        throw new Error(JSON.stringify(result.errors[0]));\n      }\n\n      if (\"error\" in result) {\n        throw new Error(JSON.stringify(result?.error));\n      }\n\n      const txn_time = result?.txn_time;\n      const txnDate = new Date(txn_time);\n      if (\n        (this.#lastTxn === undefined && txn_time !== undefined) ||\n        (txn_time !== undefined &&\n          this.#lastTxn !== undefined &&\n          this.#lastTxn < txnDate)\n      ) {\n        this.#lastTxn = txnDate;\n      }\n      return result;\n    } catch (e: any) {\n      // throw this.#getError(e);\n      throw new Error(e);\n    }\n  }\n\n  // #getError(e: any): ServiceError | ProtocolError | NetworkError | ClientError {\n  //   // see: https://axios-http.com/docs/handling_errors\n  //   if (e.response) {\n  //     // we got an error from the fauna service\n  //     if (e.response.data?.error) {\n  //       const error = e.response.data.error;\n  //       // WIP - summary is moving to a top-level field in the service\n  //       if (\n  //         error.summary === undefined &&\n  //         e.response.data.summary !== undefined\n  //       ) {\n  //         error.summary = e.response.data.summary;\n  //       }\n  //       return this.#getServiceError(error, e.response.status);\n  //     }\n  //     // we got a different error from the protocol layer\n  //     return new ProtocolError({\n  //       message: e.message,\n  //       httpStatus: e.response.status,\n  //     });\n  //   }\n  //   // we're in the browser dealing with an XMLHttpRequest that was never sent\n  //   // OR we're in node dealing with an HTTPClient.Request that never connected\n  //   // OR node or axios hit a network connection problem at a lower level,\n  //   // OR axios threw a network error\n  //   // see: https://nodejs.org/api/errors.html#nodejs-error-codes\n  //   if (\n  //     e.request?.status === 0 ||\n  //     e.request?.socket?.connecting ||\n  //     nodeOrAxiosNetworkErrorCodes.includes(e.code) ||\n  //     \"Network Error\" === e.message\n  //   ) {\n  //     return new NetworkError(\"The network connection encountered a problem.\", {\n  //       cause: e,\n  //     });\n  //   }\n  //   // unknown error\n  //   return new ClientError(\n  //     \"A client level error occurred. Fauna was not called.\",\n  //     {\n  //       cause: e,\n  //     }\n  //   );\n  // }\n\n  // #getServiceError(\n  //   error: {\n  //     code: string;\n  //     message: string;\n  //     summary?: string;\n  //     stats?: { [key: string]: number };\n  //     trace?: Array<Span>;\n  //     txn_time?: string;\n  //   },\n  //   httpStatus: number\n  // ): ServiceError {\n  //   if (httpStatus === 401) {\n  //     return new AuthenticationError({ httpStatus, ...error });\n  //   }\n  //   if (httpStatus === 403) {\n  //     return new AuthorizationError({ httpStatus, ...error });\n  //   }\n  //   if (httpStatus === 500) {\n  //     return new ServiceInternalError({ httpStatus, ...error });\n  //   }\n  //   if (httpStatus === 503) {\n  //     return new ServiceTimeoutError({ httpStatus, ...error });\n  //   }\n  //   if (httpStatus === 429) {\n  //     return new ThrottlingError({ httpStatus, ...error });\n  //   }\n  //   if (httpStatus === 440) {\n  //     // TODO stats not yet returned. Include it when it is.\n  //     return new QueryTimeoutError({ httpStatus, ...error });\n  //   }\n  //   // TODO using a list of codes to categorize as QueryCheckError\n  //   // vs QueryRutimeError is brittle and coupled to the service\n  //   // implementation.\n  //   // We need a field sent across the wire that categorizes 400s as either\n  //   // runtime failures or check failures so we are not coupled to the list\n  //   // of codes emitted by the service.\n  //   if (httpStatus === 400 && queryCheckFailureCodes.includes(error.code)) {\n  //     return new QueryCheckError({ httpStatus, ...error });\n  //   } else if (httpStatus === 400) {\n  //     return new QueryRuntimeError({ httpStatus, ...error });\n  //   }\n  //   return new ServiceError({ httpStatus, ...error });\n  // }\n\n  #setHeaders(fromObject: QueryRequestHeaders, headerObject: any): void {\n    for (const entry of Object.entries(fromObject)) {\n      if (\n        [\n          \"last_txn\",\n          \"timeout_ms\",\n          \"linearized\",\n          \"max_contention_retries\",\n          \"traceparent\",\n          \"tags\",\n        ].includes(entry[0])\n      ) {\n        let headerValue: string;\n        let headerKey = `x-${entry[0].replaceAll(\"_\", \"-\")}`;\n        if (\"tags\" === entry[0]) {\n          headerKey = \"x-fauna-tags\";\n          headerValue = Object.entries(entry[1])\n            .map((tag) => tag.join(\"=\"))\n            .join(\",\");\n        } else {\n          if (typeof entry[1] === \"string\") {\n            headerValue = entry[1];\n          } else {\n            headerValue = String(entry[1]);\n          }\n        }\n        if (\"traceparent\" === entry[0]) {\n          headerKey = entry[0];\n        }\n        headerObject[headerKey] = headerValue;\n      }\n    }\n    if (\n      headerObject[\"x-last-txn\"] === undefined &&\n      this.#lastTxn !== undefined\n    ) {\n      headerObject[\"x-last-txn\"] = this.#lastTxn.toISOString();\n    }\n  }\n}\n\n// Private types and constants for internal logic.\n\n// const queryCheckFailureCodes = [\n//   \"invalid_function_definition\",\n//   \"invalid_identifier\",\n//   \"invalid_query\",\n//   \"invalid_syntax\",\n//   \"invalid_type\",\n// ];\n\n// const nodeOrAxiosNetworkErrorCodes = [\n//   \"ECONNABORTED\",\n//   \"ECONNREFUSED\",\n//   \"ECONNRESET\",\n//   \"ERR_NETWORK\",\n//   \"ETIMEDOUT\",\n//   // axios does not yet support http2, but preparing\n//   // in case we move to a library that does or axios\n//   // adds in support.\n//   \"ERR_HTTP_REQUEST_TIMEOUT\",\n//   \"ERR_HTTP2_GOAWAY_SESSION\",\n//   \"ERR_HTTP2_INVALID_SESSION\",\n//   \"ERR_HTTP2_INVALID_STREAM\",\n//   \"ERR_HTTP2_OUT_OF_STREAMS\",\n//   \"ERR_HTTP2_SESSION_ERROR\",\n//   \"ERR_HTTP2_STREAM_CANCEL\",\n//   \"ERR_HTTP2_STREAM_ERROR\",\n// ];\n", "import { QueryFailure } from \"./wire-protocol\";\n\n/**\n * An error representing a query failure returned by Fauna.\n */\nexport class ServiceError extends Error {\n  /**\n   * The HTTP Status Code of the error.\n   */\n  readonly httpStatus: number;\n  /**\n   * A code for the error. Codes indicate the cause of the error.\n   * It is safe to write programmatic logic against the code. They are\n   * part of the API contract.\n   */\n  readonly code: string;\n  /**\n   * A summary of the error in a human readable form. Only present\n   * where message does not suffice.\n   */\n  readonly summary?: string;\n\n  constructor(failure: QueryFailure, httpStatus: number) {\n    super(failure.error.message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceError);\n    }\n\n    this.name = \"ServiceError\";\n    this.code = failure.error.code;\n    this.httpStatus = httpStatus;\n    if (failure.summary) {\n      this.summary = failure.summary;\n    }\n  }\n}\n\n/**\n * An error response that is the result of the query failing during execution.\n * QueryRuntimeError's occur when a bug in your query causes an invalid execution\n * to be requested.\n * The 'code' field will vary based on the specific error cause.\n */\nexport class QueryRuntimeError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 400) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryRuntimeError);\n    }\n    this.name = \"QueryRuntimeError\";\n    // TODO trace, txn_ts, and stats not yet returned for QueryRuntimeError\n    // flip to check for those rather than a specific code.\n  }\n}\n\n/**\n * An error due to a \"compile-time\" check of the query\n * failing.\n */\nexport class QueryCheckError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 400) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryCheckError);\n    }\n    this.name = \"QueryCheckError\";\n  }\n}\n\n/**\n * A failure due to the timeout being exceeded, but the timeout\n * was set lower than the query's expected processing time.\n * This response is distinguished from a ServiceTimeoutException\n * in that a QueryTimeoutError shows Fauna behaving in an expected\n * manner.\n */\nexport class QueryTimeoutError extends ServiceError {\n  /**\n   * Statistics regarding the query.\n   */\n  readonly stats?: { [key: string]: number };\n\n  constructor(failure: QueryFailure, httpStatus: 440) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, QueryTimeoutError);\n    }\n    this.name = \"QueryTimeoutError\";\n    this.stats = failure.stats;\n  }\n}\n\n/**\n * AuthenticationError indicates invalid credentials were\n * used.\n */\nexport class AuthenticationError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 401) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthenticationError);\n    }\n    this.name = \"AuthenticationError\";\n  }\n}\n\n/**\n * AuthorizationError indicates the credentials used do not have\n * permission to perform the requested action.\n */\nexport class AuthorizationError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 403) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AuthorizationError);\n    }\n    this.name = \"AuthorizationError\";\n  }\n}\n\n/**\n * ThrottlingError indicates some capacity limit was exceeded\n * and thus the request could not be served.\n */\nexport class ThrottlingError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 429) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ThrottlingError);\n    }\n    this.name = \"ThrottlingError\";\n  }\n}\n\n/**\n * ServiceInternalError indicates Fauna failed unexpectedly.\n */\nexport class ServiceInternalError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 500) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceInternalError);\n    }\n    this.name = \"ServiceInternalError\";\n  }\n}\n\n/**\n * ServiceTimeoutError indicates Fauna was not available to servce\n * the request before the timeout was reached.\n */\nexport class ServiceTimeoutError extends ServiceError {\n  constructor(failure: QueryFailure, httpStatus: 503) {\n    super(failure, httpStatus);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServiceTimeoutError);\n    }\n    this.name = \"ServiceTimeoutError\";\n  }\n}\n\n/**\n * An error representing a failure internal to the client, itself.\n * This indicates Fauna was never called - the client failed internally\n * prior to sending the request.\n */\nexport class ClientError extends Error {\n  constructor(message: string, options?: { cause: any }) {\n    super(message, options);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ClientError);\n    }\n    this.name = \"ClientError\";\n  }\n}\n\n/**\n * An error representing a failure due to the network.\n * This indicates Fauna was never reached.\n */\nexport class NetworkError extends Error {\n  constructor(message: string, options: { cause: any }) {\n    super(message, options);\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NetworkError);\n    }\n    this.name = \"NetworkError\";\n  }\n}\n\n/**\n * An error representing a HTTP failure - but one not directly\n * emitted by Fauna.\n */\nexport class ProtocolError extends Error {\n  /**\n   * The HTTP Status Code of the error.\n   */\n  readonly httpStatus: number;\n\n  constructor(error: { message: string; httpStatus: number }) {\n    super(error.message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ProtocolError);\n    }\n\n    this.name = \"ProtocolError\";\n    this.httpStatus = error.httpStatus;\n  }\n}\n", "// Date and Time expressions\n\nconst yearpart = /(?:\\d{4}|[\\u2212-]\\d{4,}|\\+\\d{5,})/;\nconst monthpart = /(?:0[1-9]|1[0-2])/;\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\nconst hourpart = /(?:[01][0-9]|2[0-3])/;\nconst minsecpart = /(?:[0-5][0-9])/;\nconst decimalpart = /(?:\\.\\d+)/;\n\nconst datesplit = new RegExp(\n  `(${yearpart.source}-(${monthpart.source})-(${daypart.source}))`\n);\n\nconst timesplit = new RegExp(\n  `(${hourpart.source}:${minsecpart.source}:${minsecpart.source}${decimalpart.source}?)`\n);\n\nconst zonesplit = new RegExp(\n  `([zZ]|[+\\u2212-]${hourpart.source}(?::?${minsecpart.source}|:${minsecpart.source}:${minsecpart.source}))`\n);\n\n/**\n * Matches the subset of ISO8601 dates that Fauna can accept. Cannot include any\n * time part\n */\nexport const plaindate = new RegExp(`^${datesplit.source}$`);\n\n/**\n * Matches a valid ISO8601 date and can have anything trailing after.\n */\nexport const startsWithPlaindate = new RegExp(`^${datesplit.source}`);\n\n/**\n * Matches the subset of ISO8601 times that Fauna can accept.\n */\nexport const datetime = new RegExp(\n  `^${datesplit.source}T${timesplit.source}${zonesplit.source}$`\n);\n", "import { parse } from \"path\";\nimport { ClientError } from \"./errors\";\nimport * as PARSE from \"./regex\";\n/**\n * An wrapper around the Fauna `Time` type. It, represents a fixed point in time\n * without regard to calendar or location, e.g. July 20, 1969, at 20:17 UTC.\n * Convert to and from Javascript Date's with the {@link TimeStub.fromDate} and\n * {@link TimeStub.toDate} methods.\n * See remarks for possible precision loss when doing this. If precision loss is\n * a concern consider using a 3rd party datetime library such as luxon.\n *\n * @remarks The Javascript `Date` type most closely resembles a Fauna `Time`,\n * not a Fauna `Date`. However, Fauna stores `Time` values with nanosecond\n * precision, while Javascript `Date` values only have millisecond precision.\n * This TimeStub class preserves precision by storing the original string value\n * and should be used whenever possible to pass `Time` values back to Fauna.\n * Converting to a Javascript date before sending to Fauna could result in loss\n * of precision.\n *\n * @see {@link https://deploy-preview-1272--fauna-docs.netlify.app/fqlx/beta/reference/builtin_functions/time/time}\n */\nexport class TimeStub {\n  readonly isoString: string;\n\n  /**\n   * @remarks constructor is private to enforce using factory functions\n   */\n  private constructor(isoString: string) {\n    this.isoString = isoString;\n  }\n\n  /**\n   * Creates a new {@link TimeStub} from an ISO date string\n   * @param isoString - An ISO date string.\n   * @returns A new {@link TimeStub}\n   * @throws TypeError if a string is not provided, or RangeError if item\n   * is not a valid date\n   */\n  static from(isoString: string): TimeStub {\n    if (typeof isoString !== \"string\") {\n      throw new TypeError(\n        `Expected string but received ${typeof isoString}: ${isoString}`\n      );\n    }\n    const matches = PARSE.datetime.exec(isoString);\n    if (matches === null) {\n      throw new RangeError(\n        `(regex) Expected an ISO date string but received '${isoString}'`\n      );\n    }\n    // There are some dates that match the regex but are invalid, such as Feb 31.\n    // Javascript does not parse all years that are valid in fauna, so let\n    // Fauna be the final check.\n\n    return new TimeStub(isoString);\n  }\n\n  /**\n   * Creates a new {@link TimeStub} from a Javascript `Date`\n   * @param date - A Javascript `Date`\n   * @returns A new {@link TimeStub}\n   */\n  static fromDate(date: Date): TimeStub {\n    return new TimeStub(date.toISOString());\n  }\n\n  /**\n   * Get a copy of the `TimeStub` converted to a Javascript `Date`. Does not\n   * mutate the existing `TimeStub` value.\n   * @returns A `Date`\n   */\n  toDate(): Date {\n    const date = new Date(this.isoString);\n    if (date.toString() === \"Invalid Date\") {\n      throw new RangeError(\n        \"Fauna Date could not be converted to Javascript Date\"\n      );\n    }\n    return date;\n  }\n\n  /**\n   * Override default string conversion\n   * @returns the string representation of a `TimeStub`\n   */\n  toString(): string {\n    return `TimeStub(\"${this.isoString}\")`;\n  }\n}\n\n/**\n * A wrapper aroud the Fauna `Date` type. It represents a calendar date that is\n * not associated with a particular time or time zone, e.g. August 24th, 2006.\n * Convert to and from Javascript Date's with the {@link DateStub.fromDate} and\n * {@link DateStub.toDate} methods. Javascript Dates are rendered in UTC time\n * before the date part is used.\n * See remarks for possible precision loss when doing this. If precision loss is\n * a concern consider using a 3rd party datetime library such as luxon.\n *\n * @remarks The Javascript `Date` type always has a time associated with it, but\n * Fauna's `Date` type does not. When converting from a Fauna `Date` to a\n * Javascript `Date`, we set time to 00:00:00 UTC. When converting a Javascript\n * `Date` or time string to Fauna `Date`, we convert to UTC first. Care should\n * be taken to specify the desired date, since Javascript `Date`s use local\n * timezone info by default.\n *\n * @see {@link https://deploy-preview-1272--fauna-docs.netlify.app/fqlx/beta/reference/builtin_functions/date/date}\n */\nexport class DateStub {\n  readonly dateString: string;\n\n  /**\n   * @remarks constructor is private to enforce using factory functions\n   */\n  private constructor(dateString: string) {\n    this.dateString = dateString;\n  }\n\n  /**\n   * Creates a new {@link DateStub} from a date string\n   * @param dateString - A plain date string. The time is converted to UTC\n   * before saving the date.\n   * @returns A new {@link DateStub}\n   * @throws TypeError if a string is not provided, or RangeError if dateString\n   * is not a valid date\n   */\n  static from(dateString: string): DateStub {\n    if (typeof dateString !== \"string\") {\n      throw new TypeError(\n        `Expected string but received ${typeof dateString}: ${dateString}`\n      );\n    }\n    const matches = PARSE.plaindate.exec(dateString);\n    if (matches === null) {\n      throw new RangeError(\n        `Expected a plain date string but received '${dateString}'`\n      );\n    }\n    // There are some dates that match the regex but are invalid, such as Feb 31.\n    // Javascript does not parse all years that are valid in fauna, so let\n    // Fauna be the final check.\n\n    return new DateStub(matches[0]);\n  }\n\n  /**\n   * Creates a new {@link DateStub} from a Javascript `Date`\n   * @param date - A Javascript `Date`. The time is converted to UTC before\n   * saving the date.\n   * @returns A new {@link DateStub}\n   */\n  static fromDate(date: Date): DateStub {\n    const dateString = date.toISOString();\n    const matches = PARSE.startsWithPlaindate.exec(dateString);\n    if (matches === null) {\n      // Our regex should match any possible date that comes out of\n      // `Date.toISOString()`, so we will only get here if the regex is\n      // incorrect. This is a ClientError since it is our fault.\n      throw new ClientError(`Failed to parse date '${date}'`);\n    }\n    return new DateStub(matches[0]);\n  }\n\n  /**\n   * Get a copy of the `TimeStub` converted to a Javascript `Date`. Does not\n   * mutate the existing `TimeStub` value.\n   * @returns A `Date`\n   */\n  toDate(): Date {\n    const date = new Date(this.dateString + \"T00:00:00Z\");\n    if (date.toString() === \"Invalid Date\") {\n      throw new RangeError(\n        \"Fauna Date could not be converted to Javascript Date\"\n      );\n    }\n    return date;\n  }\n\n  /**\n   * Override default string conversion\n   * @returns the string representation of a `DateStub`\n   */\n  toString(): string {\n    return `DateStub(\"${this.dateString}\")`;\n  }\n}\n", "import { DateStub, TimeStub } from \"./values\";\n\n/** A reference to a built in Fauna module; e.g. Date */\nexport type Module = string;\n/** A reference to a document in Fauna */\nexport type DocumentReference = {\n  coll: Module;\n  id: string;\n};\n\n/**\n * TaggedType provides the encoding/decoding of the Fauna Tagged Type formatting\n */\nexport class TaggedTypeFormat {\n  /**\n   * Encode the Object to the Tagged Type format for Fauna\n   *\n   * @param obj - Object that will be encoded\n   * @returns Map of result\n   */\n  static encode(obj: any): any {\n    return new TaggedTypeEncoded(obj).result;\n  }\n\n  /**\n   * Decode the JSON string result from Fauna to remove Tagged Type formatting.\n   *\n   * @param input - JSON string result from Fauna\n   * @returns object of result of FQL query\n   */\n  static decode(input: string): any {\n    return JSON.parse(input, (_, value: any) => {\n      if (value == null) return null;\n      if (value[\"@mod\"]) {\n        return value[\"@mod\"] as Module;\n      } else if (value[\"@doc\"]) {\n        if (typeof value[\"@doc\"] === \"string\") {\n          const [modName, id] = value[\"@doc\"].split(\":\");\n          return { coll: modName, id: id } as DocumentReference;\n        }\n        // if not a docref string, then it is an object.\n        return value[\"@doc\"];\n      } else if (value[\"@ref\"]) {\n        return value[\"@ref\"] as DocumentReference;\n      } else if (value[\"@set\"]) {\n        return value[\"@set\"];\n      } else if (value[\"@int\"]) {\n        return Number(value[\"@int\"]);\n      } else if (value[\"@long\"]) {\n        return BigInt(value[\"@long\"]);\n      } else if (value[\"@double\"]) {\n        return Number(value[\"@double\"]);\n      } else if (value[\"@date\"]) {\n        return DateStub.from(value[\"@date\"]);\n      } else if (value[\"@time\"]) {\n        return TimeStub.from(value[\"@time\"]);\n      } else if (value[\"@object\"]) {\n        return value[\"@object\"];\n      }\n\n      return value;\n    });\n  }\n}\n\ntype TaggedDate = { \"@date\": string };\ntype TaggedDouble = { \"@double\": string };\ntype TaggedInt = { \"@int\": string };\ntype TaggedLong = { \"@long\": string };\ntype TaggedObject = { \"@object\": Record<string, any> };\ntype TaggedTime = { \"@time\": string };\n\nexport const LONG_MIN = BigInt(\"-9223372036854775808\");\nexport const LONG_MAX = BigInt(\"9223372036854775807\");\n\nexport class TaggedTypeEncoded {\n  readonly result: any;\n\n  readonly #encodeMap = {\n    bigint: (value: bigint): TaggedLong => {\n      if (value < LONG_MIN || value > LONG_MAX) {\n        throw new RangeError(\n          \"Precision loss when converting BigInt to Fauna type\"\n        );\n      }\n\n      return {\n        \"@long\": value.toString(),\n      };\n    },\n    number: (value: number): TaggedDouble | TaggedInt | TaggedLong => {\n      if (\n        value === Number.POSITIVE_INFINITY ||\n        value === Number.NEGATIVE_INFINITY\n      ) {\n        throw new RangeError(`Cannot convert ${value} to a Fauna type.`);\n      }\n\n      if (`${value}`.includes(\".\")) {\n        return { \"@double\": value.toString() };\n      } else {\n        if (value >= -(2 ** 31) && value <= 2 ** 31 - 1) {\n          return { \"@int\": value.toString() };\n        } else if (Number.isSafeInteger(value)) {\n          return {\n            \"@long\": value.toString(),\n          };\n        }\n        return { \"@double\": value.toString() };\n      }\n    },\n    string: (value: string): string => {\n      return value;\n    },\n    object: (input: any): TaggedObject | Record<string, any> => {\n      let wrapped = false;\n      const _out: Record<string, any> = {};\n\n      for (const k in input) {\n        if (k.startsWith(\"@\")) {\n          wrapped = true;\n        }\n        _out[k] = TaggedTypeFormat.encode(input[k]);\n      }\n      return wrapped ? { \"@object\": _out } : _out;\n    },\n    array: (input: Array<any>): Array<any> => {\n      const _out: any = [];\n      for (const i in input) _out.push(TaggedTypeFormat.encode(input[i]));\n      return _out;\n    },\n    date: (dateValue: Date): TaggedTime => ({\n      \"@time\": dateValue.toISOString(),\n    }),\n    faunadate: (value: DateStub): TaggedDate => ({ \"@date\": value.dateString }),\n    faunatime: (value: TimeStub): TaggedTime => ({ \"@time\": value.isoString }),\n  };\n\n  constructor(input: any) {\n    // default to encoding directly as the input\n    this.result = input;\n\n    switch (typeof input) {\n      case \"bigint\":\n        this.result = this.#encodeMap[\"bigint\"](input);\n        break;\n      case \"string\":\n        this.result = this.#encodeMap[\"string\"](input);\n        break;\n      case \"number\":\n        this.result = this.#encodeMap[\"number\"](input);\n        break;\n      case \"object\":\n        if (input == null) {\n          this.result = null;\n        } else if (Array.isArray(input)) {\n          this.result = this.#encodeMap[\"array\"](input);\n        } else if (input instanceof Date) {\n          this.result = this.#encodeMap[\"date\"](input);\n        } else if (input instanceof DateStub) {\n          this.result = this.#encodeMap[\"faunadate\"](input);\n        } else if (input instanceof TimeStub) {\n          this.result = this.#encodeMap[\"faunatime\"](input);\n        } else {\n          this.result = this.#encodeMap[\"object\"](input);\n        }\n        break;\n    }\n  }\n}\n", "import { TaggedTypeFormat } from \"./tagged-type\";\nimport type {\n  JSONObject,\n  JSONValue,\n  QueryInterpolation,\n  QueryRequest,\n  QueryRequestHeaders,\n} from \"./wire-protocol\";\n\nexport interface QueryBuilder {\n  toQuery: (headers?: QueryRequestHeaders) => QueryRequest;\n}\n\nexport const isQueryBuilder = (obj: any): obj is QueryBuilder =>\n  obj instanceof Object && typeof obj.toQuery === \"function\";\n\n/**\n * Creates a new QueryBuilder. Accepts template literal inputs.\n * @param queryFragments - a {@link TemplateStringsArray} that constitute\n *   the strings that are the basis of the query.\n * @param queryArgs - an Array\\<JSONValue | QueryBuilder\\> that\n *   constitute the arguments to inject between the queryFragments.\n * @throws Error - if you call this method directly (not using template\n *   literals) and pass invalid construction parameters\n * @example\n * ```typescript\n *  const str = \"baz\";\n *  const num = 17;\n *  const innerQueryBuilder = fql`${num} + 3)`;\n *  const queryRequestBuilder = fql`${str}.length == ${innerQueryBuilder}`;\n * ```\n */\nexport function fql(\n  queryFragments: TemplateStringsArray,\n  ...queryArgs: (JSONValue | QueryBuilder)[]\n): QueryBuilder {\n  return new TemplateQueryBuilder(queryFragments, ...queryArgs);\n}\n\n/**\n * Internal class.\n * A builder for composing queries using the {@link fql} tagged template\n * function\n */\nclass TemplateQueryBuilder implements QueryBuilder {\n  readonly #queryFragments: TemplateStringsArray;\n  readonly #queryArgs: (JSONValue | QueryBuilder)[];\n\n  constructor(\n    queryFragments: TemplateStringsArray,\n    ...queryArgs: (JSONValue | QueryBuilder)[]\n  ) {\n    if (\n      queryFragments.length === 0 ||\n      queryFragments.length !== queryArgs.length + 1\n    ) {\n      throw new Error(\"invalid query constructed\");\n    }\n    this.#queryFragments = queryFragments;\n    this.#queryArgs = queryArgs;\n  }\n\n  /**\n   * Converts this TemplateQueryBuilder to a {@link QueryRequest} you can send\n   * to Fauna.\n   * @param requestHeaders - optional {@link QueryRequestHeaders} to include\n   *   in the request (and thus override the defaults in your {@link ClientConfiguration}.\n   *   If not passed in, no headers will be set as overrides.\n   * @returns a {@link QueryRequest}.\n   * @example\n   * ```typescript\n   *  const num = 8;\n   *  const queryBuilder = fql`'foo'.length == ${num}`;\n   *  const queryRequest = queryBuilder.toQuery();\n   *  // produces:\n   *  { query: { fql: [\"'foo'.length == \", { value: { \"@int\": \"8\" } }, \"\"] }}\n   * ```\n   */\n  toQuery(requestHeaders: QueryRequestHeaders = {}): QueryRequest {\n    return { ...this.#render(requestHeaders), ...requestHeaders };\n  }\n\n  #render(requestHeaders: QueryRequestHeaders): QueryRequest {\n    if (this.#queryFragments.length === 1) {\n      return { query: { fql: [this.#queryFragments[0]] }, arguments: {} };\n    }\n\n    let resultArgs: JSONObject = {};\n    const renderedFragments: (string | QueryInterpolation)[] =\n      this.#queryFragments.flatMap((fragment, i) => {\n        // There will always be one more fragment than there are arguments\n        if (i === this.#queryFragments.length - 1) {\n          return fragment === \"\" ? [] : [fragment];\n        }\n\n        const arg = this.#queryArgs[i];\n        let subQuery: string | QueryInterpolation;\n        if (isQueryBuilder(arg)) {\n          const request = arg.toQuery(requestHeaders);\n          subQuery = request.query;\n          resultArgs = { ...resultArgs, ...request.arguments };\n        } else {\n          // arguments in the template format must always be encoded, regardless\n          // of the \"x-format\" request header\n          // TODO: catch and rethrow Errors, indicating bad user input\n          subQuery = { value: TaggedTypeFormat.encode(arg) };\n        }\n\n        return [fragment, subQuery].filter((x) => x !== \"\");\n      });\n\n    return {\n      query: { fql: renderedFragments },\n      arguments: resultArgs,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": ["endpoints", "defaultClientConfiguration", "endpoints", "Client", "#lastTxn", "clientConfiguration", "#getSecret", "#setHeaders", "partialClientConfig", "fallback", "maybeSecret", "request", "headers", "#query", "queryRequest", "query", "args", "result", "res", "txn_time", "txnDate", "e", "fromObject", "headerObject", "entry", "headerValue", "headerKey", "tag", "ServiceError", "failure", "httpStatus", "QueryRuntimeError", "QueryCheckError", "QueryTimeoutError", "AuthenticationError", "AuthorizationError", "ThrottlingError", "ServiceInternalError", "ServiceTimeoutError", "ClientError", "message", "options", "NetworkError", "ProtocolError", "error", "yearpart", "monthpart", "daypart", "hourpart", "minsecpart", "decimalpart", "datesplit", "timesplit", "zonesplit", "plaindate", "startsWithPlaindate", "datetime", "TimeStub", "isoString", "datetime", "date", "DateStub", "dateString", "matches", "plaindate", "startsWithPlaindate", "ClientError", "TaggedTypeFormat", "obj", "TaggedTypeEncoded", "input", "_", "value", "modName", "id", "DateStub", "TimeStub", "LONG_MIN", "LONG_MAX", "#encodeMap", "wrapped", "_out", "k", "i", "dateValue", "isQueryBuilder", "obj", "fql", "queryFragments", "queryArgs", "TemplateQueryBuilder", "#queryFragments", "#queryArgs", "requestHeaders", "#render", "resultArgs", "fragment", "i", "arg", "subQuery", "request", "TaggedTypeFormat", "x"]
}
